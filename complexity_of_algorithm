● An O(1) algorithm scales the best as it never takes any longer to run.
● An O(logN) algorithm is the next most efficient.
● An O(N) algorithm is the next most efficient.
● An O(N2) algorithm is a polynomial and is considered to be the point
beyond which algorithms start to become intractable. Note that the
superscript number could be any value.
● An O(2N) algorithm is the least efficient and considered intractable.


It is possible to derive the time complexity of an algorithm by looking at the
contents of the code. For example:
● An algorithm that requires no data and contains no loops or recursion,
such as a simple assignment statement or comparison statement, will
have a time complexity of O(1).
● An algorithm that loops through an array accessing each data item once
will have a time complexity of O(N).
● An algorithm with inner and outer loops will be polynomial with
runtime increasing depending on the depth of the nesting and the
number of loops. In this case it will be O(N 2).
● The addition of a loop within the inner loop would alter the polynomial
time to O(N 3).
● An algorithm that uses recursion to call itself could have a time
complexity of O(aN).